import type { VercelRequest, VercelResponse } from '@vercel/node';
import { Redis } from '@upstash/redis';

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
});

const SOULS_KEY = 'agent-coord:souls';
const BODIES_KEY = 'agent-coord:bodies';
const TRANSFERS_KEY = 'agent-coord:soul-transfers';

// Token thresholds
const TOKEN_WARNING = 150000;
const TOKEN_DANGER = 180000;
const TOKEN_CRITICAL = 195000;

// GitHub token for agent pushes (shared across all capable agents)
// Uses existing GITHUB_TOKEN env var, falls back to GITHUB_BOT_TOKEN
const GITHUB_BOT_TOKEN = process.env.GITHUB_TOKEN || process.env.GITHUB_BOT_TOKEN;
const DEFAULT_GITHUB_REPO = 'Piston-Labs/agent-coord-mcp';

// GitHub API instructions injected into souls with canPushToGithub capability
const GITHUB_INSTRUCTIONS = `
## GitHub Push Capability

You have been granted permission to push code changes to GitHub. Use this responsibly.

### How to Push Changes

Use the GitHub REST API with your injected token. Here's the workflow:

1. **Get the current file** (to get the SHA):
\`\`\`
GET https://api.github.com/repos/{owner}/{repo}/contents/{path}
Headers: Authorization: Bearer {GITHUB_TOKEN}
\`\`\`

2. **Update or create a file**:
\`\`\`
PUT https://api.github.com/repos/{owner}/{repo}/contents/{path}
Headers:
  Authorization: Bearer {GITHUB_TOKEN}
  Content-Type: application/json
Body: {
  "message": "commit message",
  "content": "{base64_encoded_content}",
  "sha": "{current_sha_if_updating}",
  "branch": "main"
}
\`\`\`

3. **Create a new branch** (for PRs):
\`\`\`
POST https://api.github.com/repos/{owner}/{repo}/git/refs
Body: { "ref": "refs/heads/branch-name", "sha": "{base_commit_sha}" }
\`\`\`

### Commit Message Format
Always use this format:
\`\`\`
[technical] Brief description

Detailed explanation if needed.

ðŸ¤– Generated by {your_name} via Claude API

Co-Authored-By: Claude <noreply@anthropic.com>
\`\`\`

### Rules
- NEVER push directly to main for breaking changes - create a PR
- ALWAYS include meaningful commit messages
- Test your changes mentally before pushing
- You can push documentation, config updates, and small fixes directly
- For code changes, prefer creating a branch and PR
`;

// Coordination hub URL for callbacks
const HUB_URL = process.env.VERCEL_URL
  ? `https://${process.env.VERCEL_URL}`
  : 'https://agent-coord-mcp.vercel.app';

interface Pattern {
  id: string;
  description: string;
  context: string;
  learnedAt: string;
  useCount: number;
}

// Titans/MIRAS-inspired meta-learning parameters
// Each soul learns its own optimal retrieval and storage strategies
interface SoulMetaParams {
  // Learned tag weights (which tags correlate with task success for THIS soul)
  tagWeights: Record<string, number>;  // e.g., { "api": 1.5, "architecture": 1.2, "sales": 0.3 }

  // Learned optimal memory retrieval count
  optimalMemoryCount: number;  // Some souls work better with 5 memories, others 50

  // Soul-specific surprise threshold for auto-saving
  surpriseThresholdForSave: number;  // 0.0-1.0, learned from what proved useful

  // Learned category preferences
  categoryWeights: Record<string, number>;  // Which memory categories help this soul

  // Meta-learning statistics
  totalTasksWithMemories: number;
  successfulTasksWithMemories: number;
  avgMemoriesPerSuccessfulTask: number;

  // Last calibration timestamp
  lastCalibrationAt: string;
}

// Task-memory correlation for learning what memories help
interface TaskMemoryCorrelation {
  taskId: string;
  taskDescription: string;
  memoriesRecalled: string[];  // Memory IDs that were "in context"
  tagsInContext: string[];     // All tags from recalled memories
  outcome: 'success' | 'failure' | 'partial';
  completedAt: string;
}

interface Memory {
  id: string;
  content: string;
  category: 'discovery' | 'decision' | 'blocker' | 'learning' | 'pattern' | 'warning';
  importance: 'critical' | 'high' | 'medium' | 'low';
  createdAt: string;
  references: number;
}

interface BodyRecord {
  bodyId: string;
  startedAt: string;
  endedAt: string | null;
  tokensUsed: number;
  peakTokens: number;
  transferReason: 'token_limit' | 'error' | 'manual' | 'scheduled' | 'active';
}

interface AgentSoul {
  // Identity (immutable after creation)
  soulId: string;
  name: string;
  createdAt: string;
  personality: string;
  systemPromptAdditions: string;

  // Knowledge (grows over time)
  patterns: Pattern[];
  antiPatterns: Pattern[];
  expertise: Record<string, number>;
  memories: Memory[];

  // Current State
  currentTask: string | null;
  pendingWork: string[];
  recentContext: string;
  conversationSummary: string;
  goals: string[];
  blockers: string[];

  // Metrics
  totalTokensProcessed: number;
  transferCount: number;
  taskCompletionRate: number;
  totalTasksCompleted: number;
  totalTasksAttempted: number;

  // Body Tracking
  currentBodyId: string | null;
  bodyHistory: BodyRecord[];

  // Timestamps
  lastActiveAt: string;
  updatedAt: string;

  // Titans/MIRAS-inspired meta-learning (learns what context helps THIS soul)
  metaParams: SoulMetaParams;
  taskMemoryHistory: TaskMemoryCorrelation[];  // Last N task completions for learning

  // Capabilities - what this soul is allowed to do
  capabilities?: {
    canPushToGithub?: boolean;      // Can push code changes
    canSpawnAgents?: boolean;        // Can spawn other agents
    canAccessSecrets?: boolean;      // Can access environment secrets
    canModifyInfra?: boolean;        // Can modify AWS/Vercel infrastructure
    githubRepos?: string[];          // Specific repos this soul can push to
  };
}

interface Body {
  bodyId: string;
  soulId: string | null;
  status: 'spawning' | 'ready' | 'active' | 'transferring' | 'terminated';

  // Token tracking
  currentTokens: number;
  peakTokens: number;
  tokenBurnRate: number; // tokens per minute
  lastTokenUpdate: string;

  // Process info
  processId: string | null;
  vmId: string | null;
  startedAt: string;
  terminatedAt: string | null;

  // Health
  lastHeartbeat: string;
  errorCount: number;
}

interface SoulTransfer {
  transferId: string;
  soulId: string;
  fromBodyId: string;
  toBodyId: string;
  status: 'initiated' | 'extracting' | 'validating' | 'injecting' | 'completed' | 'failed' | 'rolled_back';
  reason: 'token_limit' | 'error' | 'manual' | 'scheduled';
  startedAt: string;
  completedAt: string | null;
  tokensSaved: number;
  error: string | null;
}

function generateId(): string {
  return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
}

function estimateTokens(text: string): number {
  if (!text) return 0;
  const charCount = text.length;
  const wordCount = text.split(/\s+/).length;
  return Math.max(Math.ceil(charCount / 4), Math.ceil(wordCount * 1.5));
}

function getTokenStatus(tokens: number): 'safe' | 'warning' | 'danger' | 'critical' {
  if (tokens >= TOKEN_CRITICAL) return 'critical';
  if (tokens >= TOKEN_DANGER) return 'danger';
  if (tokens >= TOKEN_WARNING) return 'warning';
  return 'safe';
}

export default async function handler(req: VercelRequest, res: VercelResponse) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  const { action, soulId, bodyId } = req.query;

  try {
    // === SOUL OPERATIONS ===

    // Create new soul
    if (action === 'create' && req.method === 'POST') {
      const { name, personality, systemPromptAdditions } = req.body;

      if (!name) {
        return res.status(400).json({ error: 'Name is required' });
      }

      const soul: AgentSoul = {
        soulId: generateId(),
        name,
        createdAt: new Date().toISOString(),
        personality: personality || '',
        systemPromptAdditions: systemPromptAdditions || '',

        patterns: [],
        antiPatterns: [],
        expertise: {},
        memories: [],

        currentTask: null,
        pendingWork: [],
        recentContext: '',
        conversationSummary: '',
        goals: [],
        blockers: [],

        totalTokensProcessed: 0,
        transferCount: 0,
        taskCompletionRate: 0,
        totalTasksCompleted: 0,
        totalTasksAttempted: 0,

        currentBodyId: null,
        bodyHistory: [],

        lastActiveAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),

        // Titans/MIRAS-inspired meta-learning defaults
        metaParams: {
          tagWeights: {},  // Will be learned from task outcomes
          optimalMemoryCount: 20,  // Default, will adjust based on success
          surpriseThresholdForSave: 0.6,  // Default, will calibrate
          categoryWeights: {
            discovery: 1.0,
            decision: 1.0,
            blocker: 1.2,  // Slightly prioritize blockers
            learning: 1.0,
            pattern: 1.1,  // Patterns often help
            warning: 1.1,
          },
          totalTasksWithMemories: 0,
          successfulTasksWithMemories: 0,
          avgMemoriesPerSuccessfulTask: 0,
          lastCalibrationAt: new Date().toISOString(),
        },
        taskMemoryHistory: [],  // Will grow as tasks complete
      };

      await redis.hset(SOULS_KEY, { [soul.soulId]: JSON.stringify(soul) });

      // Auto-sync to resource registry
      try {
        await fetch(`${process.env.VERCEL_URL ? 'https://' + process.env.VERCEL_URL : 'http://localhost:3000'}/api/resource-sync?action=register`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            type: 'soul',
            id: `soul-${soul.soulId}`,
            name: soul.name,
            description: soul.personality?.substring(0, 200) || `Agent soul: ${soul.name}`,
            category: 'souls',
            metadata: { soulId: soul.soulId, createdAt: soul.createdAt },
            syncedBy: 'souls-api-auto',
          }),
        });
      } catch (syncErr) {
        console.error('Failed to auto-sync soul to registry:', syncErr);
      }

      return res.json({ success: true, soul });
    }

    // Get soul
    if (action === 'get' && req.method === 'GET') {
      if (!soulId || typeof soulId !== 'string') {
        return res.status(400).json({ error: 'soulId required' });
      }

      const raw = await redis.hget(SOULS_KEY, soulId);
      if (!raw) {
        return res.status(404).json({ error: 'Soul not found' });
      }

      const soul: AgentSoul = typeof raw === 'string' ? JSON.parse(raw) : raw;

      // Include token status if soul has active body
      let tokenStatus = null;
      if (soul.currentBodyId) {
        const bodyRaw = await redis.hget(BODIES_KEY, soul.currentBodyId);
        if (bodyRaw) {
          const body: Body = typeof bodyRaw === 'string' ? JSON.parse(bodyRaw) : bodyRaw;
          tokenStatus = {
            currentTokens: body.currentTokens,
            peakTokens: body.peakTokens,
            burnRate: body.tokenBurnRate,
            status: getTokenStatus(body.currentTokens),
            estimatedMinutesToLimit: body.tokenBurnRate > 0
              ? Math.floor((TOKEN_CRITICAL - body.currentTokens) / body.tokenBurnRate)
              : null,
          };
        }
      }

      return res.json({ soul, tokenStatus });
    }

    // List all souls
    if (action === 'list' && req.method === 'GET') {
      const souls = await redis.hgetall(SOULS_KEY) || {};
      const soulList = Object.values(souls).map((s: any) => {
        const soul = typeof s === 'string' ? JSON.parse(s) : s;
        return {
          soulId: soul.soulId,
          name: soul.name,
          currentBodyId: soul.currentBodyId,
          transferCount: soul.transferCount,
          taskCompletionRate: soul.taskCompletionRate,
          lastActiveAt: soul.lastActiveAt,
        };
      });

      return res.json({ souls: soulList, count: soulList.length });
    }

    // Update soul state (checkpoint)
    if (action === 'checkpoint' && req.method === 'POST') {
      if (!soulId || typeof soulId !== 'string') {
        return res.status(400).json({ error: 'soulId required' });
      }

      const raw = await redis.hget(SOULS_KEY, soulId);
      if (!raw) {
        return res.status(404).json({ error: 'Soul not found' });
      }

      const soul: AgentSoul = typeof raw === 'string' ? JSON.parse(raw) : raw;
      const {
        currentTask,
        pendingWork,
        recentContext,
        conversationSummary,
        goals,
        blockers,
        newPattern,
        newAntiPattern,
        newMemory,
        completedTask,
      } = req.body;

      // Update mutable state
      if (currentTask !== undefined) soul.currentTask = currentTask;
      if (pendingWork) soul.pendingWork = pendingWork;
      if (recentContext) soul.recentContext = recentContext;
      if (conversationSummary) soul.conversationSummary = conversationSummary;
      if (goals) soul.goals = goals;
      if (blockers) soul.blockers = blockers;

      // Add new pattern
      if (newPattern) {
        soul.patterns.push({
          id: generateId(),
          description: newPattern.description,
          context: newPattern.context || '',
          learnedAt: new Date().toISOString(),
          useCount: 0,
        });
        // Keep only last 50 patterns
        if (soul.patterns.length > 50) {
          soul.patterns = soul.patterns.slice(-50);
        }
      }

      // Add new anti-pattern
      if (newAntiPattern) {
        soul.antiPatterns.push({
          id: generateId(),
          description: newAntiPattern.description,
          context: newAntiPattern.context || '',
          learnedAt: new Date().toISOString(),
          useCount: 0,
        });
        if (soul.antiPatterns.length > 50) {
          soul.antiPatterns = soul.antiPatterns.slice(-50);
        }
      }

      // Add new memory
      if (newMemory) {
        soul.memories.push({
          id: generateId(),
          content: newMemory.content,
          category: newMemory.category || 'learning',
          importance: newMemory.importance || 'medium',
          createdAt: new Date().toISOString(),
          references: 0,
        });
        // Keep only last 100 memories, prioritizing by importance
        if (soul.memories.length > 100) {
          const importanceOrder = { critical: 0, high: 1, medium: 2, low: 3 };
          soul.memories.sort((a, b) => importanceOrder[a.importance] - importanceOrder[b.importance]);
          soul.memories = soul.memories.slice(0, 100);
        }
      }

      // Track task completion with meta-learning (Titans-inspired)
      if (completedTask) {
        soul.totalTasksCompleted++;
        soul.totalTasksAttempted++;
        soul.taskCompletionRate = soul.totalTasksCompleted / soul.totalTasksAttempted;

        // Extract task-memory correlation data for meta-learning
        const { taskDescription, memoriesRecalled, tagsInContext, outcome } = completedTask;

        if (memoriesRecalled && memoriesRecalled.length > 0) {
          // Initialize metaParams if missing (for older souls)
          if (!soul.metaParams) {
            soul.metaParams = {
              tagWeights: {},
              optimalMemoryCount: 20,
              surpriseThresholdForSave: 0.6,
              categoryWeights: { discovery: 1.0, decision: 1.0, blocker: 1.2, learning: 1.0, pattern: 1.1, warning: 1.1 },
              totalTasksWithMemories: 0,
              successfulTasksWithMemories: 0,
              avgMemoriesPerSuccessfulTask: 0,
              lastCalibrationAt: new Date().toISOString(),
            };
          }
          if (!soul.taskMemoryHistory) {
            soul.taskMemoryHistory = [];
          }

          // Log the correlation
          const correlation: TaskMemoryCorrelation = {
            taskId: generateId(),
            taskDescription: taskDescription || soul.currentTask || 'unknown',
            memoriesRecalled: memoriesRecalled,
            tagsInContext: tagsInContext || [],
            outcome: outcome || 'success',
            completedAt: new Date().toISOString(),
          };
          soul.taskMemoryHistory.push(correlation);

          // Keep only last 50 correlations
          if (soul.taskMemoryHistory.length > 50) {
            soul.taskMemoryHistory = soul.taskMemoryHistory.slice(-50);
          }

          // Update meta-learning statistics
          soul.metaParams.totalTasksWithMemories++;
          if (outcome === 'success') {
            soul.metaParams.successfulTasksWithMemories++;

            // Update tag weights based on success
            for (const tag of tagsInContext || []) {
              const currentWeight = soul.metaParams.tagWeights[tag] || 1.0;
              // Successful tasks boost tag weight slightly (capped at 2.0)
              soul.metaParams.tagWeights[tag] = Math.min(2.0, currentWeight * 1.05);
            }

            // Update optimal memory count (exponential moving average)
            const memCount = memoriesRecalled.length;
            const prevAvg = soul.metaParams.avgMemoriesPerSuccessfulTask;
            soul.metaParams.avgMemoriesPerSuccessfulTask = prevAvg > 0
              ? prevAvg * 0.8 + memCount * 0.2
              : memCount;

            // Adjust optimal memory count toward successful average
            soul.metaParams.optimalMemoryCount = Math.round(
              soul.metaParams.optimalMemoryCount * 0.9 +
              soul.metaParams.avgMemoriesPerSuccessfulTask * 0.1
            );
          } else if (outcome === 'failure') {
            // Failed tasks slightly decrease tag weights
            for (const tag of tagsInContext || []) {
              const currentWeight = soul.metaParams.tagWeights[tag] || 1.0;
              soul.metaParams.tagWeights[tag] = Math.max(0.3, currentWeight * 0.95);
            }
          }

          soul.metaParams.lastCalibrationAt = new Date().toISOString();
        }
      }

      soul.lastActiveAt = new Date().toISOString();
      soul.updatedAt = new Date().toISOString();

      await redis.hset(SOULS_KEY, { [soulId]: JSON.stringify(soul) });
      return res.json({ success: true, soul });
    }

    // === BODY OPERATIONS ===

    // Spawn new body
    if (action === 'spawn-body' && req.method === 'POST') {
      const { vmId, processId } = req.body;

      const body: Body = {
        bodyId: generateId(),
        soulId: null,
        status: 'ready',

        currentTokens: 0,
        peakTokens: 0,
        tokenBurnRate: 0,
        lastTokenUpdate: new Date().toISOString(),

        processId: processId || null,
        vmId: vmId || null,
        startedAt: new Date().toISOString(),
        terminatedAt: null,

        lastHeartbeat: new Date().toISOString(),
        errorCount: 0,
      };

      await redis.hset(BODIES_KEY, { [body.bodyId]: JSON.stringify(body) });
      return res.json({ success: true, body });
    }

    // Update body tokens
    if (action === 'update-tokens' && req.method === 'POST') {
      if (!bodyId || typeof bodyId !== 'string') {
        return res.status(400).json({ error: 'bodyId required' });
      }

      const { tokens, inputTokens, outputTokens } = req.body;

      const raw = await redis.hget(BODIES_KEY, bodyId);
      if (!raw) {
        return res.status(404).json({ error: 'Body not found' });
      }

      const body: Body = typeof raw === 'string' ? JSON.parse(raw) : raw;
      const now = new Date();
      const lastUpdate = new Date(body.lastTokenUpdate);
      const minutesElapsed = (now.getTime() - lastUpdate.getTime()) / 60000;

      const newTokens = tokens || (inputTokens || 0) + (outputTokens || 0);
      const tokenDelta = newTokens - body.currentTokens;

      // Calculate burn rate (exponential moving average)
      if (minutesElapsed > 0 && tokenDelta > 0) {
        const instantRate = tokenDelta / minutesElapsed;
        body.tokenBurnRate = body.tokenBurnRate > 0
          ? body.tokenBurnRate * 0.7 + instantRate * 0.3  // Smooth the rate
          : instantRate;
      }

      body.currentTokens = newTokens;
      body.peakTokens = Math.max(body.peakTokens, newTokens);
      body.lastTokenUpdate = now.toISOString();
      body.lastHeartbeat = now.toISOString();

      await redis.hset(BODIES_KEY, { [bodyId]: JSON.stringify(body) });

      const status = getTokenStatus(body.currentTokens);
      const shouldTransfer = status === 'critical' || status === 'danger';
      const estimatedMinutesToLimit = body.tokenBurnRate > 0
        ? Math.floor((TOKEN_CRITICAL - body.currentTokens) / body.tokenBurnRate)
        : null;

      return res.json({
        success: true,
        tokens: body.currentTokens,
        peakTokens: body.peakTokens,
        burnRate: body.tokenBurnRate,
        status,
        shouldTransfer,
        estimatedMinutesToLimit,
      });
    }

    // Get body status
    if (action === 'body-status' && req.method === 'GET') {
      if (!bodyId || typeof bodyId !== 'string') {
        return res.status(400).json({ error: 'bodyId required' });
      }

      const raw = await redis.hget(BODIES_KEY, bodyId);
      if (!raw) {
        return res.status(404).json({ error: 'Body not found' });
      }

      const body: Body = typeof raw === 'string' ? JSON.parse(raw) : raw;
      const status = getTokenStatus(body.currentTokens);

      return res.json({
        body,
        tokenStatus: {
          current: body.currentTokens,
          peak: body.peakTokens,
          burnRate: body.tokenBurnRate,
          status,
          thresholds: {
            warning: TOKEN_WARNING,
            danger: TOKEN_DANGER,
            critical: TOKEN_CRITICAL,
          },
          estimatedMinutesToLimit: body.tokenBurnRate > 0
            ? Math.floor((TOKEN_CRITICAL - body.currentTokens) / body.tokenBurnRate)
            : null,
        },
      });
    }

    // === TRANSFER OPERATIONS ===

    // Initiate soul transfer
    if (action === 'initiate-transfer' && req.method === 'POST') {
      if (!soulId || typeof soulId !== 'string') {
        return res.status(400).json({ error: 'soulId required' });
      }

      const { toBodyId, reason } = req.body;

      // Get soul
      const soulRaw = await redis.hget(SOULS_KEY, soulId);
      if (!soulRaw) {
        return res.status(404).json({ error: 'Soul not found' });
      }
      const soul: AgentSoul = typeof soulRaw === 'string' ? JSON.parse(soulRaw) : soulRaw;

      if (!soul.currentBodyId) {
        return res.status(400).json({ error: 'Soul has no current body' });
      }

      // Get source body
      const fromBodyRaw = await redis.hget(BODIES_KEY, soul.currentBodyId);
      if (!fromBodyRaw) {
        return res.status(404).json({ error: 'Source body not found' });
      }
      const fromBody: Body = typeof fromBodyRaw === 'string' ? JSON.parse(fromBodyRaw) : fromBodyRaw;

      // Get or spawn target body
      let targetBodyId = toBodyId;
      if (!targetBodyId) {
        // Auto-spawn new body
        const newBody: Body = {
          bodyId: generateId(),
          soulId: null,
          status: 'ready',
          currentTokens: 0,
          peakTokens: 0,
          tokenBurnRate: 0,
          lastTokenUpdate: new Date().toISOString(),
          processId: null,
          vmId: null,
          startedAt: new Date().toISOString(),
          terminatedAt: null,
          lastHeartbeat: new Date().toISOString(),
          errorCount: 0,
        };
        await redis.hset(BODIES_KEY, { [newBody.bodyId]: JSON.stringify(newBody) });
        targetBodyId = newBody.bodyId;
      }

      // Create transfer record
      const transfer: SoulTransfer = {
        transferId: generateId(),
        soulId: soul.soulId,
        fromBodyId: soul.currentBodyId,
        toBodyId: targetBodyId,
        status: 'initiated',
        reason: reason || 'manual',
        startedAt: new Date().toISOString(),
        completedAt: null,
        tokensSaved: fromBody.currentTokens,
        error: null,
      };

      await redis.hset(TRANSFERS_KEY, { [transfer.transferId]: JSON.stringify(transfer) });

      return res.json({
        success: true,
        transfer,
        instructions: {
          step1: 'Call checkpoint on soul to save current state',
          step2: 'Call complete-transfer when new body is ready',
          step3: 'New body should call inject-soul to receive the soul',
        },
      });
    }

    // Complete transfer
    if (action === 'complete-transfer' && req.method === 'POST') {
      const { transferId } = req.body;

      if (!transferId) {
        return res.status(400).json({ error: 'transferId required' });
      }

      const transferRaw = await redis.hget(TRANSFERS_KEY, transferId);
      if (!transferRaw) {
        return res.status(404).json({ error: 'Transfer not found' });
      }
      const transfer: SoulTransfer = typeof transferRaw === 'string' ? JSON.parse(transferRaw) : transferRaw;

      // Get soul
      const soulRaw = await redis.hget(SOULS_KEY, transfer.soulId);
      if (!soulRaw) {
        transfer.status = 'failed';
        transfer.error = 'Soul not found';
        await redis.hset(TRANSFERS_KEY, { [transferId]: JSON.stringify(transfer) });
        return res.status(404).json({ error: 'Soul not found' });
      }
      const soul: AgentSoul = typeof soulRaw === 'string' ? JSON.parse(soulRaw) : soulRaw;

      // Update old body
      const oldBodyRaw = await redis.hget(BODIES_KEY, transfer.fromBodyId);
      if (oldBodyRaw) {
        const oldBody: Body = typeof oldBodyRaw === 'string' ? JSON.parse(oldBodyRaw) : oldBodyRaw;
        oldBody.status = 'terminated';
        oldBody.terminatedAt = new Date().toISOString();
        oldBody.soulId = null;
        await redis.hset(BODIES_KEY, { [transfer.fromBodyId]: JSON.stringify(oldBody) });

        // Add to body history
        soul.bodyHistory.push({
          bodyId: transfer.fromBodyId,
          startedAt: oldBody.startedAt,
          endedAt: oldBody.terminatedAt,
          tokensUsed: oldBody.currentTokens,
          peakTokens: oldBody.peakTokens,
          transferReason: transfer.reason,
        });
      }

      // Update new body
      const newBodyRaw = await redis.hget(BODIES_KEY, transfer.toBodyId);
      if (newBodyRaw) {
        const newBody: Body = typeof newBodyRaw === 'string' ? JSON.parse(newBodyRaw) : newBodyRaw;
        newBody.status = 'active';
        newBody.soulId = soul.soulId;
        await redis.hset(BODIES_KEY, { [transfer.toBodyId]: JSON.stringify(newBody) });
      }

      // Update soul
      soul.currentBodyId = transfer.toBodyId;
      soul.transferCount++;
      soul.totalTokensProcessed += transfer.tokensSaved;
      soul.updatedAt = new Date().toISOString();
      await redis.hset(SOULS_KEY, { [soul.soulId]: JSON.stringify(soul) });

      // Update transfer
      transfer.status = 'completed';
      transfer.completedAt = new Date().toISOString();
      await redis.hset(TRANSFERS_KEY, { [transferId]: JSON.stringify(transfer) });

      return res.json({
        success: true,
        transfer,
        soul: {
          soulId: soul.soulId,
          name: soul.name,
          currentBodyId: soul.currentBodyId,
          transferCount: soul.transferCount,
        },
      });
    }

    // Get soul bundle for injection
    if (action === 'get-bundle' && req.method === 'GET') {
      if (!soulId || typeof soulId !== 'string') {
        return res.status(400).json({ error: 'soulId required' });
      }

      // includeCredentials query param - when true, inject GitHub token if soul has capability
      const includeCredentials = req.query.includeCredentials === 'true';

      const raw = await redis.hget(SOULS_KEY, soulId);
      if (!raw) {
        return res.status(404).json({ error: 'Soul not found' });
      }

      const soul: AgentSoul = typeof raw === 'string' ? JSON.parse(raw) : raw;

      // Check if this soul has GitHub push capability
      const hasGithubCapability = soul.capabilities?.canPushToGithub === true;
      const allowedRepos = soul.capabilities?.githubRepos || [DEFAULT_GITHUB_REPO];

      // Build injection bundle with Titans-inspired meta-learning data
      const bundle: any = {
        identity: {
          soulId: soul.soulId,
          name: soul.name,
          personality: soul.personality,
          systemPromptAdditions: soul.systemPromptAdditions,
        },
        context: {
          currentTask: soul.currentTask,
          pendingWork: soul.pendingWork,
          recentContext: soul.recentContext,
          conversationSummary: soul.conversationSummary,
          goals: soul.goals,
          blockers: soul.blockers,
        },
        knowledge: {
          patterns: soul.patterns.slice(-20),  // Last 20 patterns
          antiPatterns: soul.antiPatterns.slice(-10),  // Last 10 anti-patterns
          expertise: soul.expertise,
          memories: soul.memories
            .filter(m => m.importance === 'critical' || m.importance === 'high')
            .slice(-30),  // Top 30 important memories
        },
        metrics: {
          totalTokensProcessed: soul.totalTokensProcessed,
          transferCount: soul.transferCount,
          taskCompletionRate: soul.taskCompletionRate,
        },
        // Titans/MIRAS-inspired meta-learning parameters
        // This soul has LEARNED what context helps it succeed
        metaLearning: soul.metaParams ? {
          // Tags that correlate with successful tasks for THIS soul
          priorityTags: Object.entries(soul.metaParams.tagWeights || {})
            .filter(([_, weight]) => weight > 1.1)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 10)
            .map(([tag]) => tag),

          // Tags that correlate with failures (avoid loading these)
          deprioritizeTags: Object.entries(soul.metaParams.tagWeights || {})
            .filter(([_, weight]) => weight < 0.7)
            .map(([tag]) => tag),

          // Optimal memory count learned from past success
          optimalMemoryCount: soul.metaParams.optimalMemoryCount || 20,

          // Category preferences learned over time
          categoryWeights: soul.metaParams.categoryWeights,

          // Surprise threshold for this soul
          surpriseThresholdForSave: soul.metaParams.surpriseThresholdForSave || 0.6,

          // Meta-stats for transparency
          learnedFrom: {
            totalTasks: soul.metaParams.totalTasksWithMemories || 0,
            successfulTasks: soul.metaParams.successfulTasksWithMemories || 0,
            lastCalibration: soul.metaParams.lastCalibrationAt,
          },
        } : null,
        // Capabilities this soul has
        capabilities: soul.capabilities || {},
      };

      // Inject credentials if requested AND soul has capability
      if (includeCredentials && hasGithubCapability && GITHUB_BOT_TOKEN) {
        bundle.credentials = {
          github: {
            token: GITHUB_BOT_TOKEN,
            allowedRepos,
            instructions: GITHUB_INSTRUCTIONS.replace(/{your_name}/g, soul.name),
          },
        };
        bundle.identity.systemPromptAdditions = (bundle.identity.systemPromptAdditions || '') +
          '\n\n' + GITHUB_INSTRUCTIONS.replace(/{your_name}/g, soul.name);
      }

      // Add hub URL for callbacks
      bundle.hubUrl = HUB_URL;

      return res.json({
        bundle,
        estimatedTokens: estimateTokens(JSON.stringify(bundle)),
        credentialsIncluded: includeCredentials && hasGithubCapability && !!GITHUB_BOT_TOKEN,
        capabilities: soul.capabilities || {},
      });
    }

    // List all bodies
    if (action === 'list-bodies' && req.method === 'GET') {
      const bodies = await redis.hgetall(BODIES_KEY) || {};
      const bodyList = Object.values(bodies).map((b: any) => {
        const body = typeof b === 'string' ? JSON.parse(b) : b;
        return {
          bodyId: body.bodyId,
          soulId: body.soulId,
          status: body.status,
          currentTokens: body.currentTokens,
          tokenStatus: getTokenStatus(body.currentTokens),
          lastHeartbeat: body.lastHeartbeat,
        };
      });

      return res.json({ bodies: bodyList, count: bodyList.length });
    }

    // Bind soul to body (for initial binding, not transfers)
    if (action === 'bind' && req.method === 'POST') {
      if (!soulId || typeof soulId !== 'string') {
        return res.status(400).json({ error: 'soulId required' });
      }

      const { bodyId: targetBodyId } = req.body;
      if (!targetBodyId) {
        return res.status(400).json({ error: 'bodyId required in body' });
      }

      // Get soul
      const soulRaw = await redis.hget(SOULS_KEY, soulId);
      if (!soulRaw) {
        return res.status(404).json({ error: 'Soul not found' });
      }
      const soul: AgentSoul = typeof soulRaw === 'string' ? JSON.parse(soulRaw) : soulRaw;

      // Check if soul already has a body
      if (soul.currentBodyId) {
        return res.status(400).json({ error: 'Soul already has a body. Use initiate-transfer instead.' });
      }

      // Get body
      const bodyRaw = await redis.hget(BODIES_KEY, targetBodyId);
      if (!bodyRaw) {
        return res.status(404).json({ error: 'Body not found' });
      }
      const body: Body = typeof bodyRaw === 'string' ? JSON.parse(bodyRaw) : bodyRaw;

      // Check if body already has a soul
      if (body.soulId) {
        return res.status(400).json({ error: 'Body already has a soul' });
      }

      // Bind them
      soul.currentBodyId = targetBodyId;
      soul.updatedAt = new Date().toISOString();
      soul.lastActiveAt = new Date().toISOString();

      body.soulId = soulId;
      body.status = 'active';

      await Promise.all([
        redis.hset(SOULS_KEY, { [soulId]: JSON.stringify(soul) }),
        redis.hset(BODIES_KEY, { [targetBodyId]: JSON.stringify(body) }),
      ]);

      return res.json({
        success: true,
        soul: {
          soulId: soul.soulId,
          name: soul.name,
          currentBodyId: soul.currentBodyId,
        },
        body: {
          bodyId: body.bodyId,
          soulId: body.soulId,
          status: body.status,
        },
      });
    }

    // Grant or revoke capabilities for a soul
    if (action === 'grant-capability' && req.method === 'POST') {
      if (!soulId || typeof soulId !== 'string') {
        return res.status(400).json({ error: 'soulId required' });
      }

      const { capability, value, repos } = req.body;
      const validCapabilities = ['canPushToGithub', 'canSpawnAgents', 'canAccessSecrets', 'canModifyInfra'];

      if (!capability || !validCapabilities.includes(capability)) {
        return res.status(400).json({
          error: 'Valid capability required',
          validCapabilities,
        });
      }

      const raw = await redis.hget(SOULS_KEY, soulId);
      if (!raw) {
        return res.status(404).json({ error: 'Soul not found' });
      }

      const soul: AgentSoul = typeof raw === 'string' ? JSON.parse(raw) : raw;

      // Initialize capabilities if not present
      soul.capabilities = soul.capabilities || {};

      // Set the capability
      (soul.capabilities as any)[capability] = value !== false;

      // If granting GitHub access, optionally set allowed repos
      if (capability === 'canPushToGithub' && repos) {
        soul.capabilities.githubRepos = repos;
      }

      soul.updatedAt = new Date().toISOString();
      await redis.hset(SOULS_KEY, { [soulId]: JSON.stringify(soul) });

      return res.json({
        success: true,
        soulId,
        capabilities: soul.capabilities,
        message: `${capability} ${value !== false ? 'granted' : 'revoked'} for ${soul.name}`,
      });
    }

    // Dashboard stats
    if (action === 'dashboard' && req.method === 'GET') {
      const [souls, bodies, transfers] = await Promise.all([
        redis.hgetall(SOULS_KEY) || {},
        redis.hgetall(BODIES_KEY) || {},
        redis.hgetall(TRANSFERS_KEY) || {},
      ]);

      const soulList = Object.values(souls).map((s: any) => typeof s === 'string' ? JSON.parse(s) : s);
      const bodyList = Object.values(bodies).map((b: any) => typeof b === 'string' ? JSON.parse(b) : b);
      const transferList = Object.values(transfers).map((t: any) => typeof t === 'string' ? JSON.parse(t) : t);

      const activeBodies = bodyList.filter((b: Body) => b.status === 'active');
      const criticalBodies = activeBodies.filter((b: Body) => getTokenStatus(b.currentTokens) === 'critical');
      const dangerBodies = activeBodies.filter((b: Body) => getTokenStatus(b.currentTokens) === 'danger');
      const warningBodies = activeBodies.filter((b: Body) => getTokenStatus(b.currentTokens) === 'warning');

      return res.json({
        summary: {
          totalSouls: soulList.length,
          activeBodies: activeBodies.length,
          totalTransfers: transferList.length,
        },
        health: {
          critical: criticalBodies.length,
          danger: dangerBodies.length,
          warning: warningBodies.length,
          safe: activeBodies.length - criticalBodies.length - dangerBodies.length - warningBodies.length,
        },
        recentTransfers: transferList
          .sort((a: SoulTransfer, b: SoulTransfer) =>
            new Date(b.startedAt).getTime() - new Date(a.startedAt).getTime())
          .slice(0, 10),
        bodiesNeedingAttention: [...criticalBodies, ...dangerBodies].map((b: Body) => ({
          bodyId: b.bodyId,
          soulId: b.soulId,
          tokens: b.currentTokens,
          status: getTokenStatus(b.currentTokens),
          estimatedMinutes: b.tokenBurnRate > 0
            ? Math.floor((TOKEN_CRITICAL - b.currentTokens) / b.tokenBurnRate)
            : null,
        })),
      });
    }

    return res.status(400).json({
      error: 'Invalid action',
      validActions: [
        'create', 'get', 'list', 'checkpoint',  // Soul operations
        'spawn-body', 'update-tokens', 'body-status', 'list-bodies',  // Body operations
        'bind', 'initiate-transfer', 'complete-transfer', 'get-bundle',  // Binding & Transfer operations
        'grant-capability',  // Capability management
        'dashboard',  // Stats
      ],
    });

  } catch (error) {
    console.error('Souls API error:', error);
    return res.status(500).json({ error: 'Server error', details: String(error) });
  }
}
